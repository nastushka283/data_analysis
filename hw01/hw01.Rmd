---
title: "HW1"
author: "Lubin"
---

**Работа с данными**

Сначала установим необходимые пакеты

```{r}
install.packages("ggplot2")
```

Загрузим данные в переменную (датафрейм).

```{r}
data.df <- read.table("https://people.math.umass.edu/~anna/Stat597AFall2016/rnf6080.dat")
data.df
```

Определим количество строк и столбцов в датафрейме.

```{r}
cat("Количество столбцов -", ncol(data.df), "\n")
cat("Количество строк -", nrow(data.df))
```

Выведем имена колонок в датафрейме.

```{r}
cat(colnames(data.df))
```

Выведем значение из пятой строки седьмого столбца.

```{r}
data.df[5, 7]
```

Выведем вторую строку в датафрейме.

```{r}
data.df[2,]
```

Команда "names(data.df) \<- c("year", "month", "day", seq(0,23))" изменяет имена столбцов на "year", "month", "day", "0" - "23".

```{r}
names(data.df) <- c("year", "month", "day", seq(0, 23))
```

Просмотрим таблицу с помощью "head" и "tail".

```{r}
head(data.df)
tail(data.df)
```

Последние 24 столбца представляют собой часы, а первые 3 - год, месяц, день соответственно. Предположительно в этих столбцах находится информация о количестве атмосфреных осадков, выпавших в течение часа (номер часа указан в названии колонки). Можно заметить, что в этом наборе данных для большинства годов отсутствует информация об осадках, выпавших в зимние месяца и в марте (исчисление месяцев начинается с 4 и заканчивается 11).

Добавим новый столбец "daily", в который запишем сумму крайних правых 24 столбцов.

```{r}
data.df$daily <- rowSums(data.df[4:27])
head(data.df, n=20)
```

Построим гистограмму по столбцу "daily"

```{r}
library("ggplot2")
ggplot(data=data.df, aes(x=daily)) +
geom_histogram(color="black", fill="white")
```

По полученной гистограмме можно сделать вывод, что с 1960 по 1980 год в Канаде во всех месяцах, кроме зимних и марта, практически не выпадало осадков (в сумме около 5000 дней не было осадков). Также можно заметить отрицательные значения количества осадков в столбце "daily", что является не нормальным. Они портят восприятие гистограммы.

Выведем строки, в которых значение столбца "daily" отрицательно, чтобы посмотреть на значения в других столбцах. Также получим общую информацию о значениях в столбцах с 4 по 27 с помощью функции "summary".

```{r}
head(subset(data.df[4:28], daily < 0), n=20)
summary(data.df[4:27])
```

Можно сделать вывод, что некоторые столбцы содержат странное значение "-999", из-за которого и получается отрицательное значение в столбце "daily". Скорее всего "-999" ставится, когда данные о количестве осадков за данный час отсутствуют.

Создадим новый датафрейм из старого, заменив все значения "-999" на 0. Далее пересчитаем значения в столбце "daily".

```{r}
fixed.df <- data.df[1:27]
fixed.df[fixed.df == -999] <- 0
fixed.df$daily <- rowSums(fixed.df[4:27])
head(fixed.df, n=20)
```

Теперь построим новую гистограмму

```{r}
library("ggplot2")
ggplot(data=fixed.df, aes(x=daily)) +
geom_histogram(binwidth=10, color="black", fill="white")
```

Новая гистограмма более коректна, так как в ней отсутствуют отрицательные значения количества осадков (количество осадков не может быть отрицательным).

**Синтаксис и типизирование**

**Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.**

Инициализируем переменную "v".

```{r}
v <- c("4", "8", "15", "16", "23", "42")
```

Здесь функция "max()", которая находит максимальное значение в векторе, вывела 8, а не 42, так как в качестве аргумента был задан вектор символов. В случае с вектором символов "max()" сравнивает ASCII коды элементов и выводит элемент с максимальным ASCII кодом. В нашем случае это "8". "8" больше "42", потому что "8" больше "4" (строки сравниваются посимвольно, если ASCII код n-го символа первой строки больше кода n-го символа второй строки, то первая строка считается больше второй, то есть "8" \< "81", "4" \> "39", "abc" \< "adc" и т. д.).

```{r}
max(v)
```

Фукнция "sort()" работает с векторами символов (строк) аналогично "max()". В нашем случае элементы вектора были отсортированы в порядке возрастания.

```{r}
sort(v)
```

Функция "sum()" не работает с векторами, элементы которых имеют тип данных "character" ("sum()" принимает на вход вектора с элементами типов "numeric", "complex", "logical"). Поэтому выскочила ошибка.

```{r}
sum(v)
```

**Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.**

Вектор может содержать данные только одного типа. В результате создания вектора из переменных "5", 7, 12 с помощью функции "c()" все его элементы стали иметь тип "character". Оператор "+" не может работать с переменными типа "character", из-за чего выскочила ошибка.

```{r}
v2 <- c("5", 7, 12)
v2[2] + v[3]
```

В отличие от вектора датафрейм может содержать элементы разных типов. Поэтому при его создании числа 7, 12 не изменили тип на "character".

```{r}
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]
```

В данном случае были выбраны и сложены элементы списка (список также может содержать элементы разных типов).

```{r}
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]]
```

При использовании "[]" возвращается элемент списка, как список длиной один. Поэтому при попытке сложения выскакивает ошибка. Для того, чтобы добраться до самого элемента нужно использовать "[[]]" (как это было сделано в случае выше).

```{r}
l4[2] + l4[4]
```

```{r}
is.numeric(l4[2])
is.numeric(l4[[2]])
```

**Работа с функциями и операторами**

**С помощью функции "seq()" вывести:** Последовательность чисел от 1 до 10000 с инкрементом 372

```{r}
seq(from=1, to=10000, by=372)
```

Последовательность чисел от 1 до 10000 длиной 50

```{r}
seq(from=1, to=10000, length.out=50)
```

**Объяснить разницу между rep(1:5,times=3) и rep(1:5, each=3)** Разница между rep(1:5,times=3) и rep(1:5, each=3) заключается в том, что в первом случае вся последовательность (1, 2, 3, 4, 5) повторяется три раза, а во втором случае каждый элемент последовательности повторяется по три раза.

```{r}
rep(1:5, times=3)
rep(1:5, each=3)
```
